#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_debug_printf : enable

#include "Lighting.glsl"

struct Vertex
{
  vec3 Position;
	float	  Padding1;
	vec3 Normal;
	float	  Padding2;
	vec2 TexureCoord;
	vec2 Padding3;
	vec3 Tangant;
	float	  Padding4;
	vec3 BiTangant;
	float	  Padding5;
	vec4 Color;
	ivec4 BoneID ;
	vec4 BoneWeights;
 };

layout(binding = 0, scalar) buffer Vertices
{
  Vertex v[];
}
vertices;

layout(binding = 2) uniform UniformBufferObject {
	mat4 viewInverse;
	mat4 projInverse;
    mat4 model;
    mat4 view;
    mat4 proj;
    DirectionalLight dlight;
	vec3 viewPos;
	PointLight plight;
    float vertexSize;
    mat4 PVM;
    mat4 BoneTransform[100];
    float timer;
} ubo;
layout(binding = 5) buffer Transform { mat4 Transform; } MeshTransform[];

layout(push_constant) uniform MeshInfo
{
	uint MeshID;
	uint ModelID;
	uint MaterialID;
} Mesh;

void main()
{
  debugPrintfEXT("Hit");
  Vertex v0 = vertices.v[gl_GlobalInvocationID.x];
    debugPrintfEXT("Hit");
  mat4 BoneTransform = mat4(1.0f);
    debugPrintfEXT("Hit");
  BoneTransform =  ubo.BoneTransform[v0.BoneID[0]] * v0.BoneWeights[0];
  BoneTransform += ubo.BoneTransform[v0.BoneID[1]] * v0.BoneWeights[1];
  BoneTransform += ubo.BoneTransform[v0.BoneID[2]] * v0.BoneWeights[2];
  BoneTransform += ubo.BoneTransform[v0.BoneID[3]] * v0.BoneWeights[3];
  vec4 BonePosition = BoneTransform * vec4(v0.Position, 1.0);
  debugPrintfEXT("Hit");

  v0.Position = vec3(ubo.model * MeshTransform[0].Transform * BonePosition);
    debugPrintfEXT("Hit");
  v0.Normal = normalize(transpose(inverse(mat3(ubo.model * MeshTransform[0].Transform * BoneTransform))) * v0.Normal);
      debugPrintfEXT("Hit");
	v0.Color = vec4(v0.BoneID.xyz, 1.0f);
	  debugPrintfEXT("Hit");
  vertices.v[gl_GlobalInvocationID.x] = v0;
}