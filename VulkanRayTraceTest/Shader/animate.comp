#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "Lighting.glsl"

struct Vertex
{
  vec3 pos;
  float padding1;
  vec3 normal;
  float padding2;
  vec2 uv;
  vec2 padding3;
  vec4 tangent;
  vec4 BiTangant;
  vec4 Color;
  vec4 BoneID;
  vec4 BoneWeights;
 };

layout(binding = 0) buffer Vertices
{
  Vertex v[];
} vertices;

layout(binding = 2) uniform UniformBufferObject {
	mat4 viewInverse;
	mat4 projInverse;
    mat4 model;
    mat4 view;
    mat4 proj;
    DirectionalLight dlight;
	vec3 viewPos;
	PointLight plight;
    int vertexSize;
    mat4 PVM;
    mat4 BoneTransform[100];
    float timer;
} ubo;
layout(binding = 5) buffer Transform { mat4 Transform; } MeshTransform[];

layout(push_constant) uniform MeshInfo
{
	uint MeshID;
	uint ModelID;
	uint MaterialID;
} Mesh;

void main()
{
  Vertex v0 = vertices.v[gl_GlobalInvocationID.x];

  mat4 BoneTransform = mat4(1.0f);
  BoneTransform =  ubo.BoneTransform[int(v0.BoneID[0])] * v0.BoneWeights[0];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[1])] * v0.BoneWeights[1];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[2])] * v0.BoneWeights[2];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[3])] * v0.BoneWeights[3];
  vec4 BonePosition = BoneTransform * vec4(v0.pos, 1.0);

  vertices.v[gl_GlobalInvocationID.x].pos = vec3(ubo.model * MeshTransform[Mesh.MeshID].Transform * BonePosition);
}