#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

#include "Lighting.glsl"

struct Vertex
{
  vec3 pos;
  float padding1;
  vec3 normal;
  float padding2;
  vec2 uv;
  vec2 padding3;
  vec4 tangent;
  vec4 BiTangant;
  vec4 Color;
  vec4 BoneID;
  vec4 BoneWeights;
 };

layout(binding = 0, scalar) buffer Vertices
{
  Vertex v[];
}
vertices;

layout(binding = 2) uniform UniformBufferObject {
	mat4 viewInverse;
	mat4 projInverse;
    mat4 model;
    mat4 view;
    mat4 proj;
    DirectionalLight dlight;
	vec3 viewPos;
	PointLight plight;
    float vertexSize;
    mat4 PVM;
    mat4 BoneTransform[100];
    float timer;
} ubo;
layout(binding = 5) buffer Transform { mat4 Transform; } MeshTransform[];

layout(push_constant) uniform MeshInfo
{
	uint MeshID;
	uint ModelID;
	uint MaterialID;
} Mesh;

void main()
{
  Vertex v0 = vertices.v[gl_GlobalInvocationID.x];

  // Compute vertex position
  const float PI       = 3.14159265;
  const float signY    = (v0.pos.y >= 0 ? 1 : -1);
  const float radius   = length(v0.pos.xz);
  const float argument = ubo.vertexSize * 4 + radius * PI;
  const float s        = sin(argument);

    mat4 BoneTransform = mat4(1.0f);
  BoneTransform =  ubo.BoneTransform[int(v0.BoneID[0])] * v0.BoneWeights[0];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[1])] * v0.BoneWeights[1];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[2])] * v0.BoneWeights[2];
  BoneTransform += ubo.BoneTransform[int(v0.BoneID[3])] * v0.BoneWeights[3];
  vec4 BonePosition = BoneTransform * vec4(v0.pos, 1.0);

  //v0.pos = vec3(ubo.model * MeshTransform[Mesh.MeshID].Transform * BonePosition);
  //v0.Color = vec4(MeshTransform[Mesh.MeshID].Transform);
  // Compute normal
  if(radius == 0.0f)
  {
    v0.normal = vec3(0.0f, signY, 0.0f);
  }
  else
  {
    const float c        = cos(argument);
    const float xzFactor = -PI * s * c;
    const float yFactor  = 2.0f * signY * radius * abs(s);
  //  v0.normal               = normalize(vec3(v0.pos.x * xzFactor, yFactor, v0.pos.z * xzFactor));
  }

  vertices.v[gl_GlobalInvocationID.x] = v0;
}